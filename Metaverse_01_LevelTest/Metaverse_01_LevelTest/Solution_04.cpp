// 문제를 파악한 내용 : 수의 배열을 정렬할 수 있는가
// 해결 아이디어 : 이중 for문으로 첫 수부터 뒤의 수와 하나씩 비교, 본인이 더 크면 서로 바꾼다. 배열의 끝 수까지 끝난다면 그 다음 수, 둘째 수부터 다시 시작, 이렇게 마지막 수부터 시작할 때까지 반복한다. 이는 O(n^2)의 그리 좋지 못한 알고리즘이라 알고 있지만, 현재로써는 이 방법 외에는 생각이 나지 않는다.

void swap(int* a, int* b)			// 숫자 교환 함수
{
	int temp;						// 임시 저장소
	temp = *a;
	*a = *b;
	*b = temp;
}

void sortArray(int* arr, int n)		// 정렬 함수
{
	for (int j = n; j > 1; j--)		// 첫 수부터 비교, 반복 횟수는 배열의 크기와 같다.
	{
		for (int i = 1; i < j; i++)	// 하나씩 바로 다음 수와 비교, 교환한다.
		{
			int* aP = arr + i - 1;
			int* bP = arr + i;
			
			if (*aP > *bP)			// 만약 앞 수가 뒷 수보다 크다면
			{
				swap(aP, bP);		// 교환
			}
		}
	}
}